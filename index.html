<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cluster Image Puzzle</title>

  <!-- ✅ AdSense: 승인 후 아래 script 주석을 해제하세요. -->
  <!--
  <script async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXX"
    crossorigin="anonymous"></script>
  -->

  <style>
    :root{
      --banner-h: 100px; /* 320x100 */
      --topbar-h: 52px;
    }

    html, body {
      margin:0;
      height:100%;
      background:#0f0f10;
      color:#eee;
      font-family:system-ui, sans-serif;
      box-sizing:border-box;

      padding-bottom: calc(var(--banner-h) + env(safe-area-inset-bottom, 0px));
      padding-top: calc(var(--topbar-h) + env(safe-area-inset-top, 0px));

      overscroll-behavior: none;
      touch-action: none;
    }

    .app {
      min-height: 100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      box-sizing:border-box;
    }

    .stage {
      position:relative;
      width:min(720px, 96vw);
    }

    canvas {
      width:100%;
      height:auto;
      display:block;
      background:#000;
      border:1px solid #2a2a2a;
      border-radius:12px;
      touch-action: none;
    }

    /* Clear Overlay */
    .overlay {
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }
    .panel {
      pointer-events:auto;
      background:rgba(10,10,12,0.72);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:16px;
      padding:18px;
      min-width:min(360px, 86%);
      text-align:center;
      backdrop-filter: blur(6px);
    }
    .title { font-size:28px; font-weight:800; margin:0 0 6px 0; }
    .lv { font-size:14px; opacity:0.92; margin:0 0 10px 0; }
    .sub { font-size:14px; opacity:0.9; margin:0 0 14px 0; line-height:1.4; }
    .btn {
      appearance:none; border:0;
      background:#fff; color:#111;
      padding:12px 16px;
      border-radius:12px;
      font-weight:800;
      cursor:pointer;
      width:100%;
    }
    .btn:hover { filter:brightness(0.95); }
    .btn:active { transform: translateY(1px); }

    /* pill */
    .pill {
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.14);
      font-size: 12px;
      cursor:pointer;
      backdrop-filter: blur(6px);
      color:#fff;
    }
    .dot {
      width:10px; height:10px; border-radius:99px;
      background: rgba(255,255,255,0.28);
      border: 1px solid rgba(255,255,255,0.20);
    }
    .pill.on .dot { background: rgba(110,255,170,0.75); }
    .pill.off { opacity: 0.72; }

    /* ✅ TOPBAR */
    #topbar{
      position: fixed;
      left: 0; right: 0;
      top: 0;
      height: calc(var(--topbar-h) + env(safe-area-inset-top, 0px));
      padding-top: env(safe-area-inset-top, 0px);
      background: rgba(0,0,0,0.55);
      border-bottom: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      z-index: 10000;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #topbar .topbar-inner{
      width: min(720px, 96vw);
      display:flex;
      justify-content:flex-end;
      gap: 8px;
      padding: 0 12px;
      box-sizing:border-box;
      height: var(--topbar-h);
      align-items:center;
    }

    /* ✅ bottom banner */
    #bottom-banner {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: calc(var(--banner-h) + env(safe-area-inset-bottom, 0px));
      padding-bottom: env(safe-area-inset-bottom, 0px);
      background: rgba(0,0,0,0.92);
      border-top: 1px solid rgba(255,255,255,0.12);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    #bottom-banner .inner {
      width: min(720px, 100%);
      height: var(--banner-h);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 8px;
      box-sizing:border-box;
      position: relative;
    }

    #bottom-banner ins.adsbygoogle {
      display:block;
      width: 100%;
      height: 100%;
      min-height: var(--banner-h);
    }

    #ad-fallback {
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
      opacity:0.55;
      pointer-events:none;
    }
  </style>
</head>

<body>
  <!-- ✅ TOPBAR DOM -->
  <div id="topbar">
    <div class="topbar-inner">
      <div class="pill on" id="bgmToggle" role="button" aria-label="BGM toggle">
        <span class="dot"></span><span>BGM</span>
      </div>
      <div class="pill on" id="sfxToggle" role="button" aria-label="SFX toggle">
        <span class="dot"></span><span>SFX</span>
      </div>
    </div>
  </div>

  <div class="app">
    <div class="stage">
      <canvas id="c" width="720" height="720"></canvas>

      <div class="overlay" id="overlay" style="display:none;">
        <div class="panel">
          <div class="title">CLEAR!</div>
          <div class="lv" id="lvText">Level 1</div>
          <p class="sub">다음 레벨로 진행할 수 있어요</p>
          <button class="btn" id="nextBtn">다음 레벨</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ✅ Bottom Ad banner -->
  <div id="bottom-banner">
    <div class="inner">
      <!-- 승인 후 아래 ins/script 주석 해제 + client/slot 입력 -->
      <!--
      <ins class="adsbygoogle"
           data-ad-client="ca-pub-XXXXXXXXXXXXXXX"
           data-ad-slot="1234567890"
           data-ad-format="rectangle"
           data-full-width-responsive="true"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      -->
      <div id="ad-fallback">Ad banner area (320×100)</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const overlayEl = document.getElementById("overlay");
  const nextBtn = document.getElementById("nextBtn");
  const lvText = document.getElementById("lvText");

  const bgmToggleEl = document.getElementById("bgmToggle");
  const sfxToggleEl = document.getElementById("sfxToggle");
  const adFallbackEl = document.getElementById("ad-fallback");

  // ----------------------------
  // Image pool (./images/)
  // ----------------------------
  const IMAGE_POOL = [
    "images/01.jpg","images/02.jpg","images/03.jpg","images/04.jpg",
    "images/05.jpg","images/06.jpg","images/07.jpg","images/08.jpg",
  ];

  // ----------------------------
  // Difficulty curve
  // ----------------------------
  let level = 1;
  function getNForLevel(lv){
    if (lv === 1) return 2;
    if (lv === 2 || lv === 3) return 3;
    if (lv >= 4 && lv <= 9) return 4;
    if (lv >= 10 && lv <= 19) return 5;
    return 6;
  }

  let N = getNForLevel(level);
  const PADDING = 12;
  const TILE_GAP = 2;
  const DRAG_ALPHA = 0.98;

  const START_HINT_SEC = 0.8;
  let hintTimer = 0;

  let sourceImage = null;
  let isLoading = false;

  let board = [];
  let solved = [];

  let dragging = null;
  let activePointerId = null;

  // Pop animation
  const tilePop = new Map();
  const POP_DUR = 0.12;
  const POP_MAG = 0.06;

  // ----------------------------
  // ✅ Audio (복구)
  // ----------------------------
  let audioCtx = null;
  let master = { bgmOn:true, sfxOn:true };

  // (이전 네 요청대로 약간 큰 편)
  const SFX_GAIN = 0.36;
  const CLEAR_GAIN = 0.44;
  const BGM_GAIN = 0.11;

  let bgm = {
    playing: false,
    gain: null,
    nextNoteTime: 0,
    step: 0,
    timer: null
  };

  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
  }

  function setToggleUI(el, on){
    el.classList.toggle("on", on);
    el.classList.toggle("off", !on);
  }
  setToggleUI(bgmToggleEl, master.bgmOn);
  setToggleUI(sfxToggleEl, master.sfxOn);

  bgmToggleEl.addEventListener("click", () => {
    master.bgmOn = !master.bgmOn;
    setToggleUI(bgmToggleEl, master.bgmOn);
    if (bgm.gain) bgm.gain.gain.value = master.bgmOn ? BGM_GAIN : 0.0001;
  });

  sfxToggleEl.addEventListener("click", () => {
    master.sfxOn = !master.sfxOn;
    setToggleUI(sfxToggleEl, master.sfxOn);
  });

  // SFX: 착붙 크리링~
  function playChime(){
    if (!master.sfxOn) return;
    try{
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const notes = [
        { f: 1568, t: 0.00, d: 0.10 },
        { f: 1319, t: 0.07, d: 0.12 },
      ];
      for (const n of notes){
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(n.f, t0 + n.t);

        gain.gain.setValueAtTime(0.0001, t0 + n.t);
        gain.gain.exponentialRampToValueAtTime(SFX_GAIN, t0 + n.t + 0.015);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + n.t + n.d);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(t0 + n.t);
        osc.stop(t0 + n.t + n.d + 0.02);
      }
    } catch {}
  }

  // SFX: 클리어 뾰로롱~
  function playClear(){
    if (!master.sfxOn) return;
    try{
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const seq = [
        { f: 1046.5, t: 0.00, d: 0.12 },
        { f: 1318.5, t: 0.10, d: 0.12 },
        { f: 1568.0, t: 0.20, d: 0.14 },
        { f: 2093.0, t: 0.34, d: 0.18 },
      ];
      for (const n of seq){
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(n.f, t0 + n.t);

        gain.gain.setValueAtTime(0.0001, t0 + n.t);
        gain.gain.exponentialRampToValueAtTime(CLEAR_GAIN, t0 + n.t + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + n.t + n.d);

        osc.detune.setValueAtTime(-6, t0 + n.t);
        osc.detune.linearRampToValueAtTime(6, t0 + n.t + n.d);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(t0 + n.t);
        osc.stop(t0 + n.t + n.d + 0.03);
      }
    } catch {}
  }

  // BGM: 밝고 발랄한 루프
  function startBgmIfNeeded(){
    try{
      ensureAudio();
      if (bgm.playing) return;

      bgm.gain = audioCtx.createGain();
      bgm.gain.gain.value = master.bgmOn ? BGM_GAIN : 0.0001;
      bgm.gain.connect(audioCtx.destination);

      bgm.playing = true;
      bgm.step = 0;
      bgm.nextNoteTime = audioCtx.currentTime + 0.05;

      const tempo = 132;
      const spb = 60 / tempo;
      const stepDur = spb / 2;

      const scale = [
        261.63, 329.63, 392.00, 523.25,
        392.00, 329.63, 293.66, 349.23,
      ];

      function scheduleNote(time, freq, dur){
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, time);

        g.gain.setValueAtTime(0.0001, time);
        g.gain.exponentialRampToValueAtTime(0.12, time + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, time + dur);

        osc.connect(g);
        g.connect(bgm.gain);

        osc.start(time);
        osc.stop(time + dur + 0.01);
      }

      function scheduler(){
        if (!bgm.playing) return;
        const lookAhead = 0.10;
        while (bgm.nextNoteTime < audioCtx.currentTime + lookAhead){
          const i = bgm.step % scale.length;
          let f = scale[i];
          if (bgm.step % 16 === 12) f *= 2;

          const dur = (bgm.step % 8 === 6) ? stepDur * 0.65 : stepDur * 0.85;
          scheduleNote(bgm.nextNoteTime, f, dur);

          bgm.nextNoteTime += stepDur;
          bgm.step++;
        }
      }

      bgm.timer = setInterval(scheduler, 25);
    } catch {}
  }

  // ----------------------------
  // Ad fallback
  // ----------------------------
  function setupAdFallback(){
    let hasRealAd = false;
    function check(){
      const ins = document.querySelector("ins.adsbygoogle");
      if (!ins) { adFallbackEl.style.display = "flex"; return; }
      const filled = ins.querySelector("iframe, *") || ins.offsetHeight >= 60;
      if (filled) hasRealAd = true;
      adFallbackEl.style.display = hasRealAd ? "none" : "flex";
    }
    setTimeout(check, 800);
    setTimeout(check, 1800);
    setTimeout(check, 3200);
  }
  setupAdFallback();

  // ----------------------------
  // Board helpers
  // ----------------------------
  function idx(r,c){ return r*N + c; }
  function rc(pos){ return { r: Math.floor(pos / N), c: pos % N }; }

  function resetBoard(){
    solved = Array.from({length:N*N}, (_,i)=>i);
    board = solved.slice();
  }

  function shuffleBoard(){
    for (let i = board.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [board[i], board[j]] = [board[j], board[i]];
    }
    if (isSolved()) shuffleBoard();
  }

  function isSolved(){
    for (let i=0;i<board.length;i++){
      if (board[i] !== solved[i]) return false;
    }
    return true;
  }

  function boardRect(){
    const W = canvas.width, H = canvas.height;
    const size = Math.min(W,H) - PADDING*2;
    return { x:(W-size)/2, y:(H-size)/2, size };
  }

  function posFromPoint(px, py){
    const br = boardRect();
    if (px < br.x || py < br.y || px > br.x+br.size || py > br.y+br.size) return null;
    const cell = br.size / N;
    const c = Math.floor((px - br.x) / cell);
    const r = Math.floor((py - br.y) / cell);
    const p = r*N + c;
    return (p>=0 && p<N*N) ? p : null;
  }

  function drawTile(tileId, dx, dy, dw, dh){
    const img = sourceImage;
    const tileW = img.width / N;
    const tileH = img.height / N;
    const sr = Math.floor(tileId / N);
    const sc = tileId % N;
    const sx = sc * tileW;
    const sy = sr * tileH;
    ctx.drawImage(img, sx, sy, tileW, tileH, dx, dy, dw, dh);
  }

  // Cluster lock
  function isLockedAdj(posA, posB, dir){
    const idA = board[posA];
    const idB = board[posB];
    const a = { r: Math.floor(idA / N), c: idA % N };
    const b = { r: Math.floor(idB / N), c: idB % N };
    return (b.r === a.r + dir.dr) && (b.c === a.c + dir.dc);
  }

  function getCluster(anchorPos){
    const visited = new Set([anchorPos]);
    const q = [anchorPos];
    const dirs = [{dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}];
    while (q.length){
      const p = q.shift();
      const { r, c } = rc(p);
      for (const d of dirs){
        const nr = r + d.dr, nc = c + d.dc;
        if (nr<0||nr>=N||nc<0||nc>=N) continue;
        const np = idx(nr,nc);
        if (visited.has(np)) continue;
        if (isLockedAdj(p, np, d)){
          visited.add(np);
          q.push(np);
        }
      }
    }
    const aRC = rc(anchorPos);
    return Array.from(visited).map(pos => {
      const prc = rc(pos);
      return { pos, tileId: board[pos], offR: prc.r - aRC.r, offC: prc.c - aRC.c };
    }).sort((m1,m2)=>(m1.offR-m2.offR)||(m1.offC-m2.offC));
  }

  function clusterFitsAt(members, anchorPos){
    const aRC = rc(anchorPos);
    for (const m of members){
      const rr = aRC.r + m.offR;
      const cc = aRC.c + m.offC;
      if (rr<0||rr>=N||cc<0||cc>=N) return false;
    }
    return true;
  }

  // overlap-safe move
  function applyClusterMoveOverlapSafe(members, toAnchorPos){
    const old = board.slice();
    const srcPositions = members.map(m => m.pos);
    const aRC = rc(toAnchorPos);
    const dstPositions = members.map(m => idx(aRC.r + m.offR, aRC.c + m.offC));

    const srcSet = new Set(srcPositions);
    const dstSet = new Set(dstPositions);

    const next = board.slice();

    for (let i=0;i<members.length;i++){
      next[dstPositions[i]] = old[srcPositions[i]];
    }

    const vacated = [];
    const displaced = [];
    for (let i=0;i<members.length;i++){
      const sp = srcPositions[i];
      const dp = dstPositions[i];
      if (!dstSet.has(sp)) vacated.push(sp);
      if (!srcSet.has(dp)) displaced.push(old[dp]);
    }
    const k = Math.min(vacated.length, displaced.length);
    for (let i=0;i<k;i++){
      next[vacated[i]] = displaced[i];
    }
    board = next;
  }

  // Pop effect
  function popScaleForTile(tileId){
    const t = tilePop.get(tileId);
    if (!t) return 1;
    const a = Math.max(0, Math.min(1, 1 - (t / POP_DUR)));
    return 1 + POP_MAG * Math.sin(a * Math.PI);
  }

  function render(dt){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#0b0b0c";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    if (!sourceImage){
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "16px system-ui, sans-serif";
      ctx.fillText(isLoading ? "Loading..." : "No image", 18, 26);
      return;
    }

    const br = boardRect();
    ctx.fillStyle = "#121214";
    ctx.fillRect(br.x-2, br.y-2, br.size+4, br.size+4);

    const cell = br.size / N;

    if (hintTimer > 0){
      const alpha = Math.min(0.22, (hintTimer / START_HINT_SEC) * 0.22);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.drawImage(sourceImage, br.x, br.y, br.size, br.size);
      ctx.restore();
    }

    const draggingPosSet = new Set(dragging ? dragging.members.map(m => m.pos) : []);
    for (let pos=0; pos<N*N; pos++){
      if (draggingPosSet.has(pos)) continue;

      const tileId = board[pos];
      const { r, c } = rc(pos);
      const x0 = br.x + c*cell + TILE_GAP/2;
      const y0 = br.y + r*cell + TILE_GAP/2;
      const w0 = cell - TILE_GAP;
      const h0 = cell - TILE_GAP;

      const s = popScaleForTile(tileId);
      const cx = x0 + w0/2;
      const cy = y0 + h0/2;
      const w = w0 * s;
      const h = h0 * s;

      ctx.save();
      ctx.translate(cx - w/2, cy - h/2);
      drawTile(tileId, 0, 0, w, h);
      ctx.restore();

      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x0+0.5, y0+0.5, w0-1, h0-1);
    }

    if (dragging){
      const baseX = dragging.mouseX - dragging.grabDX;
      const baseY = dragging.mouseY - dragging.grabDY;

      ctx.save();
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = "#000";
      for (const m of dragging.members){
        const x = baseX + m.offC*cell + 6;
        const y = baseY + m.offR*cell + 8;
        ctx.fillRect(x, y, cell - TILE_GAP, cell - TILE_GAP);
      }
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = DRAG_ALPHA;
      for (const m of dragging.members){
        const x = baseX + m.offC*cell;
        const y = baseY + m.offR*cell;
        drawTile(m.tileId, x, y, cell - TILE_GAP, cell - TILE_GAP);
        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.lineWidth = 2;
        ctx.strokeRect(x+0.5, y+0.5, (cell - TILE_GAP)-1, (cell - TILE_GAP)-1);
      }
      ctx.restore();
    }
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    for (const [id, t] of tilePop.entries()){
      const nt = t - dt;
      if (nt <= 0) tilePop.delete(id);
      else tilePop.set(id, nt);
    }

    if (hintTimer > 0) hintTimer = Math.max(0, hintTimer - dt);

    render(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Pointer input
  function getCanvasPointFromPointer(evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
    const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  function onPointerDown(evt){
    if (!sourceImage || isLoading) return;
    if (activePointerId != null) return;

    // ✅ 모바일에서 오디오 unlock + BGM 시작
    startBgmIfNeeded();

    activePointerId = evt.pointerId;
    canvas.setPointerCapture(activePointerId);

    const p = getCanvasPointFromPointer(evt);
    const pos = posFromPoint(p.x, p.y);
    if (pos == null) return;

    const members = getCluster(pos);

    const br = boardRect();
    const cell = br.size / N;
    const { r, c } = rc(pos);
    const gx = br.x + c*cell + TILE_GAP/2;
    const gy = br.y + r*cell + TILE_GAP/2;

    dragging = {
      anchorPos: pos,
      members,
      mouseX: p.x,
      mouseY: p.y,
      grabDX: (p.x - gx),
      grabDY: (p.y - gy),
    };

    evt.preventDefault();
  }

  function onPointerMove(evt){
    if (evt.pointerId !== activePointerId) return;
    if (!dragging) return;

    const p = getCanvasPointFromPointer(evt);
    dragging.mouseX = p.x;
    dragging.mouseY = p.y;

    evt.preventDefault();
  }

  function onPointerUp(evt){
    if (evt.pointerId !== activePointerId) return;
    activePointerId = null;
    if (!dragging) return;

    const p = getCanvasPointFromPointer(evt);
    const dropAnchorPos = posFromPoint(p.x, p.y);

    // move
    if (dropAnchorPos != null &&
        dropAnchorPos !== dragging.anchorPos &&
        clusterFitsAt(dragging.members, dropAnchorPos)) {
      applyClusterMoveOverlapSafe(dragging.members, dropAnchorPos);
    }

    // 착붙 팝(간단): 이동 후 클러스터가 2개 이상이면 팝 + chime
    // (원래 “성장 조건” 로직이 있으면 여기 대신 그 로직을 넣으면 됨)
    const cl = getCluster(dropAnchorPos ?? dragging.anchorPos);
    if (cl.length >= 2) {
      for (const m of cl) tilePop.set(m.tileId, POP_DUR);
      playChime();
    }

    dragging = null;

    if (isSolved()){
      lvText.textContent = `Level ${level}`;
      overlayEl.style.display = "flex";
      playClear();
    }

    evt.preventDefault();
  }

  canvas.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove, { passive:false });
  window.addEventListener("pointerup", onPointerUp, { passive:false });
  window.addEventListener("pointercancel", onPointerUp, { passive:false });

  // Image loading
  function centerCropToSquare(img, size=1024){
    const off = document.createElement("canvas");
    off.width = off.height = size;
    const g = off.getContext("2d");
    const iw = img.naturalWidth, ih = img.naturalHeight;
    const s = Math.min(iw, ih);
    const sx = (iw - s) / 2;
    const sy = (ih - s) / 2;
    g.drawImage(img, sx, sy, s, s, 0, 0, size, size);
    return off;
  }

  async function loadImageToSource(url){
    isLoading = true;
    overlayEl.style.display = "none";

    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        sourceImage = centerCropToSquare(img, 1024);
        isLoading = false;
        resolve(true);
      };
      img.onerror = () => {
        const fallback = document.createElement("canvas");
        fallback.width = fallback.height = 1024;
        const g = fallback.getContext("2d");
        g.fillStyle = "#222";
        g.fillRect(0,0,1024,1024);
        g.fillStyle = "#fff";
        g.font = "bold 44px system-ui, sans-serif";
        g.fillText("Missing image", 60, 120);
        g.font = "20px system-ui, sans-serif";
        g.fillText(url, 60, 160);
        sourceImage = fallback;
        isLoading = false;
        resolve(false);
      };
      img.src = url;
    });
  }

  async function startLevel(lv){
    level = lv;
    N = getNForLevel(level);

    const pick = IMAGE_POOL[(level - 1) % IMAGE_POOL.length];
    await loadImageToSource(pick);

    resetBoard();
    shuffleBoard();

    tilePop.clear();
    dragging = null;

    hintTimer = START_HINT_SEC;
    overlayEl.style.display = "none";
  }

  nextBtn.addEventListener("click", async () => {
    await startLevel(level + 1);
  });

  startLevel(level);
})();
</script>
</body>
</html>
