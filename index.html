<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cluster Image Puzzle</title>

  <!-- ✅ AdSense: 승인 후 아래 script 주석을 해제하세요. -->
  <!--
  <script async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXX"
    crossorigin="anonymous"></script>
  -->

  <style>
    :root{
      --banner-h: 100px; /* 320x100 */
      --topbar-h: 52px;
    }

    html, body {
      margin:0;
      height:100%;
      background:#0f0f10;
      color:#eee;
      font-family:system-ui, sans-serif;
      box-sizing:border-box;

      /* 상단바/하단배너 공간 확보 */
      padding-top: calc(var(--topbar-h) + env(safe-area-inset-top, 0px));
      padding-bottom: calc(var(--banner-h) + env(safe-area-inset-bottom, 0px));

      overscroll-behavior: none;
      touch-action: none;
    }

    .app {
      min-height: 100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      box-sizing:border-box;
    }

    .stage {
      position:relative;
      width:min(720px, 96vw);
    }

    canvas {
      width:100%;
      height:auto;
      display:block;
      background:#000;
      border:1px solid #2a2a2a;
      border-radius:12px;
      touch-action: none;
    }

    /* Clear Overlay */
    .overlay {
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }
    .panel {
      pointer-events:auto;
      background:rgba(10,10,12,0.72);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:16px;
      padding:18px;
      min-width:min(360px, 86%);
      text-align:center;
      backdrop-filter: blur(6px);
    }
    .title { font-size:28px; font-weight:800; margin:0 0 6px 0; }
    .lv { font-size:14px; opacity:0.92; margin:0 0 10px 0; }
    .sub { font-size:14px; opacity:0.9; margin:0 0 14px 0; line-height:1.4; }
    .btn {
      appearance:none; border:0;
      background:#fff; color:#111;
      padding:12px 16px;
      border-radius:12px;
      font-weight:800;
      cursor:pointer;
      width:100%;
    }
    .btn:hover { filter:brightness(0.95); }
    .btn:active { transform: translateY(1px); }

    /* pill */
    .pill {
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.14);
      font-size: 12px;
      cursor:pointer;
      backdrop-filter: blur(6px);
      color:#fff;
      white-space: nowrap;
    }
    .dot {
      width:10px; height:10px; border-radius:99px;
      background: rgba(255,255,255,0.28);
      border: 1px solid rgba(255,255,255,0.20);
    }
    .pill.on .dot { background: rgba(110,255,170,0.75); }
    .pill.off { opacity: 0.72; }

    /* ✅ TOPBAR: 버전 / 레벨 / 힌트 / 버튼 */
    #topbar{
      position: fixed;
      left: 0; right: 0;
      top: 0;
      height: calc(var(--topbar-h) + env(safe-area-inset-top, 0px));
      padding-top: env(safe-area-inset-top, 0px);
      background: rgba(0,0,0,0.55);
      border-bottom: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      z-index: 10000;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #topbar .topbar-inner{
      width: min(720px, 96vw);
      display:grid;
      grid-template-columns: auto 1fr auto;
      align-items:center;
      padding: 0 12px;
      height: var(--topbar-h);
      box-sizing:border-box;
      gap: 10px;
    }
    .topbar-left{
      font-size: 12px;
      opacity: 0.85;
      white-space: nowrap;
    }
    .topbar-center{
      text-align: center;
      font-weight: 700;
      font-size: 14px;
      letter-spacing: 0.2px;
      white-space: nowrap;
    }
    .topbar-right{
      display:flex;
      gap: 8px;
      align-items:center;
      justify-content:flex-end;
      white-space: nowrap;
    }

    /* ✅ bottom banner */
    #bottom-banner {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: calc(var(--banner-h) + env(safe-area-inset-bottom, 0px));
      padding-bottom: env(safe-area-inset-bottom, 0px);
      background: rgba(0,0,0,0.92);
      border-top: 1px solid rgba(255,255,255,0.12);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    #bottom-banner .inner {
      width: min(720px, 100%);
      height: var(--banner-h);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 8px;
      box-sizing:border-box;
      position: relative;
    }

    #bottom-banner ins.adsbygoogle {
      display:block;
      width: 100%;
      height: 100%;
      min-height: var(--banner-h);
    }

    #ad-fallback {
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
      opacity:0.55;
      pointer-events:none;
    }

    /* ✅ PC에서 배너가 캔버스를 가리면 이 옵션이 가장 안전 */
    @media (min-width: 900px) {
      #bottom-banner { display:none !important; }
      html, body { padding-bottom: 0 !important; }
    }
  </style>
</head>

<body>
  <!-- ✅ TOPBAR DOM -->
  <div id="topbar">
    <div class="topbar-inner">
      <div class="topbar-left"><span class="version">v0.00.12</span></div>
      <div class="topbar-center"><span id="levelLabel">Level 1 / 30</span></div>
      <div class="topbar-right">
        <div class="pill" id="hintBtn" role="button" aria-label="Hint">
          <span>HINT</span>
        </div>
        <div class="pill on" id="bgmToggle" role="button" aria-label="BGM toggle">
          <span class="dot"></span><span>BGM</span>
        </div>
        <div class="pill on" id="sfxToggle" role="button" aria-label="SFX toggle">
          <span class="dot"></span><span>SFX</span>
        </div>
      </div>
    </div>
  </div>

  <div class="app">
    <div class="stage">
      <canvas id="c" width="720" height="720"></canvas>

      <div class="overlay" id="overlay" style="display:none;">
        <div class="panel">
          <div class="title">CLEAR!</div>
          <div class="lv" id="lvText">Level 1 / 30</div>
          <p class="sub">다음 레벨로 진행할 수 있어요</p>
          <button class="btn" id="nextBtn">다음 레벨</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ✅ Bottom Ad banner -->
  <div id="bottom-banner">
    <div class="inner">
      <!-- 승인 후 아래 ins/script 주석 해제 + client/slot 입력 -->
      <!--
      <ins class="adsbygoogle"
           data-ad-client="ca-pub-XXXXXXXXXXXXXXX"
           data-ad-slot="1234567890"
           data-ad-format="rectangle"
           data-full-width-responsive="true"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      -->
      <div id="ad-fallback">Ad banner area (320×100)</div>
    </div>
  </div>

<script>
(() => {
  const VERSION = "0.00.12";
  const TOTAL_LEVELS = 30;

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const overlayEl = document.getElementById("overlay");
  const nextBtn = document.getElementById("nextBtn");
  const lvText = document.getElementById("lvText");
  const levelLabel = document.getElementById("levelLabel");
  const hintBtn = document.getElementById("hintBtn");

  const bgmToggleEl = document.getElementById("bgmToggle");
  const sfxToggleEl = document.getElementById("sfxToggle");
  const adFallbackEl = document.getElementById("ad-fallback");

  // ----------------------------
  // Image pool (./images/)
  // 01.jpg ~ 30.jpg 가정 (없으면 fallback 캔버스 표시)
  // ----------------------------
  const IMAGE_POOL = Array.from({length: TOTAL_LEVELS}, (_,i) => {
    const n = String(i+1).padStart(2,"0");
    return `images/${n}.jpg`;
  });

  // ----------------------------
  // Difficulty curve
  // ----------------------------
  let level = 1;
  function getNForLevel(lv){
    if (lv === 1) return 2;
    if (lv === 2 || lv === 3) return 3;
    if (lv >= 4 && lv <= 9) return 4;
    if (lv >= 10 && lv <= 19) return 5;
    return 6;
  }

  let N = getNForLevel(level);
  const PADDING = 12;
  const TILE_GAP = 2;
  const DRAG_ALPHA = 0.98;

  // Start hint (0.8s)
  const START_HINT_SEC = 0.8;
  let hintTimer = 0;

  // ✅ "번호 힌트" (3초)
  const NUMBER_HINT_SEC = 3.0;
  let numberHintTimer = 0;

  // Image source
  let sourceImage = null;
  let isLoading = false;

  // Board
  let board = [];
  let solved = [];

  // Drag cluster state
  let dragging = null;
  let activePointerId = null;

  // Pop animation
  const tilePop = new Map();
  const POP_DUR = 0.12;
  const POP_MAG = 0.06;

  // Fireworks particles on clear
  let fireworks = [];
  let didClearFx = false;

  // ----------------------------
  // Audio
  // ----------------------------
  let audioCtx = null;
  let master = { bgmOn:true, sfxOn:true };

  const SFX_GAIN = 0.36;
  const CLEAR_GAIN = 0.44;
  const BGM_GAIN = 0.11;

  let bgm = {
    playing: false,
    gain: null,
    nextNoteTime: 0,
    step: 0,
    timer: null
  };

  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
  }

  function setToggleUI(el, on){
    el.classList.toggle("on", on);
    el.classList.toggle("off", !on);
  }
  setToggleUI(bgmToggleEl, master.bgmOn);
  setToggleUI(sfxToggleEl, master.sfxOn);

  bgmToggleEl.addEventListener("click", () => {
    startBgmIfNeeded();
    master.bgmOn = !master.bgmOn;
    setToggleUI(bgmToggleEl, master.bgmOn);
    if (bgm.gain) bgm.gain.gain.value = master.bgmOn ? BGM_GAIN : 0.0001;
  });

  sfxToggleEl.addEventListener("click", () => {
    startBgmIfNeeded();
    master.sfxOn = !master.sfxOn;
    setToggleUI(sfxToggleEl, master.sfxOn);
  });

  // ✅ 힌트 버튼
  hintBtn.addEventListener("click", () => {
    // 오디오 unlock 겸(원하면 제거해도 됨)
    startBgmIfNeeded();
    numberHintTimer = NUMBER_HINT_SEC; // 누를 때마다 3초로 리셋
  });

  // 착붙: 크리링~
  function playChime(){
    if (!master.sfxOn) return;
    try{
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const notes = [
        { f: 1568, t: 0.00, d: 0.10 },
        { f: 1319, t: 0.07, d: 0.12 },
      ];
      for (const n of notes){
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(n.f, t0 + n.t);

        gain.gain.setValueAtTime(0.0001, t0 + n.t);
        gain.gain.exponentialRampToValueAtTime(SFX_GAIN, t0 + n.t + 0.015);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + n.t + n.d);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(t0 + n.t);
        osc.stop(t0 + n.t + n.d + 0.02);
      }
    } catch {}
  }

  // 클리어: 뾰로롱~
  function playClear(){
    if (!master.sfxOn) return;
    try{
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const seq = [
        { f: 1046.5, t: 0.00, d: 0.12 },
        { f: 1318.5, t: 0.10, d: 0.12 },
        { f: 1568.0, t: 0.20, d: 0.14 },
        { f: 2093.0, t: 0.34, d: 0.18 },
      ];
      for (const n of seq){
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(n.f, t0 + n.t);

        gain.gain.setValueAtTime(0.0001, t0 + n.t);
        gain.gain.exponentialRampToValueAtTime(CLEAR_GAIN, t0 + n.t + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + n.t + n.d);

        osc.detune.setValueAtTime(-6, t0 + n.t);
        osc.detune.linearRampToValueAtTime(6, t0 + n.t + n.d);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(t0 + n.t);
        osc.stop(t0 + n.t + n.d + 0.03);
      }
    } catch {}
  }

  // BGM: 밝고 발랄한 루프
  function startBgmIfNeeded(){
    try{
      ensureAudio();
      if (bgm.playing) return;

      bgm.gain = audioCtx.createGain();
      bgm.gain.gain.value = master.bgmOn ? BGM_GAIN : 0.0001;
      bgm.gain.connect(audioCtx.destination);

      bgm.playing = true;
      bgm.step = 0;
      bgm.nextNoteTime = audioCtx.currentTime + 0.05;

      const tempo = 132;
      const spb = 60 / tempo;
      const stepDur = spb / 2;

      const scale = [
        261.63, 329.63, 392.00, 523.25,
        392.00, 329.63, 293.66, 349.23,
      ];

      function scheduleNote(time, freq, dur){
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, time);

        g.gain.setValueAtTime(0.0001, time);
        g.gain.exponentialRampToValueAtTime(0.12, time + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, time + dur);

        osc.connect(g);
        g.connect(bgm.gain);

        osc.start(time);
        osc.stop(time + dur + 0.01);
      }

      function scheduler(){
        if (!bgm.playing) return;
        const lookAhead = 0.10;
        while (bgm.nextNoteTime < audioCtx.currentTime + lookAhead){
          const i = bgm.step % scale.length;
          let f = scale[i];
          if (bgm.step % 16 === 12) f *= 2;

          const dur = (bgm.step % 8 === 6) ? stepDur * 0.65 : stepDur * 0.85;
          scheduleNote(bgm.nextNoteTime, f, dur);

          bgm.nextNoteTime += stepDur;
          bgm.step++;
        }
      }

      bgm.timer = setInterval(scheduler, 25);
    } catch {}
  }

  // ----------------------------
  // Ad fallback
  // ----------------------------
  function setupAdFallback(){
    let hasRealAd = false;
    function check(){
      const ins = document.querySelector("ins.adsbygoogle");
      if (!ins) { adFallbackEl.style.display = "flex"; return; }
      const filled = ins.querySelector("iframe, *") || ins.offsetHeight >= 60;
      if (filled) hasRealAd = true;
      adFallbackEl.style.display = hasRealAd ? "none" : "flex";
    }
    setTimeout(check, 800);
    setTimeout(check, 1800);
    setTimeout(check, 3200);
  }
  setupAdFallback();

  // ----------------------------
  // Board helpers
  // ----------------------------
  function idx(r,c){ return r*N + c; }
  function rc(pos){ return { r: Math.floor(pos / N), c: pos % N }; }

  function resetBoard(){
    solved = Array.from({length:N*N}, (_,i)=>i);
    board = solved.slice();
  }

  function shuffleBoard(){
    for (let i = board.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [board[i], board[j]] = [board[j], board[i]];
    }
    if (isSolved()) shuffleBoard();
  }

  function isSolved(){
    for (let i=0;i<board.length;i++){
      if (board[i] !== solved[i]) return false;
    }
    return true;
  }

  function boardRect(){
    const W = canvas.width, H = canvas.height;
    const size = Math.min(W,H) - PADDING*2;
    return { x:(W-size)/2, y:(H-size)/2, size };
  }

  function posFromPoint(px, py){
    const br = boardRect();
    if (px < br.x || py < br.y || px > br.x+br.size || py > br.y+br.size) return null;
    const cell = br.size / N;
    const c = Math.floor((px - br.x) / cell);
    const r = Math.floor((py - br.y) / cell);
    const p = r*N + c;
    return (p>=0 && p<N*N) ? p : null;
  }

  function drawTile(tileId, dx, dy, dw, dh){
    const img = sourceImage;
    const tileW = img.width / N;
    const tileH = img.height / N;
    const sr = Math.floor(tileId / N);
    const sc = tileId % N;
    const sx = sc * tileW;
    const sy = sr * tileH;
    ctx.drawImage(img, sx, sy, tileW, tileH, dx, dy, dw, dh);
  }

  // ✅ 번호 힌트: 타일 위에 "정답 위치 번호" = (tileId + 1)
  function drawHintNumberOnTile(tileId, cx, cy, cell){
    const num = tileId + 1; // 핵심!
    ctx.save();
    ctx.globalAlpha = 0.26;              // 희미하게
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `800 ${Math.max(14, cell*0.28)}px system-ui, sans-serif`;

    // 가독성 살짝만 (너무 진하면 힌트가 과해짐)
    ctx.shadowColor = "rgba(0,0,0,0.60)";
    ctx.shadowBlur = 6;

    ctx.fillText(String(num), cx, cy);
    ctx.restore();
  }

  // Cluster lock
  function isLockedAdj(posA, posB, dir){
    const idA = board[posA];
    const idB = board[posB];
    const a = { r: Math.floor(idA / N), c: idA % N };
    const b = { r: Math.floor(idB / N), c: idB % N };
    return (b.r === a.r + dir.dr) && (b.c === a.c + dir.dc);
  }

  function getCluster(anchorPos){
    const visited = new Set([anchorPos]);
    const q = [anchorPos];
    const dirs = [{dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}];
    while (q.length){
      const p = q.shift();
      const { r, c } = rc(p);
      for (const d of dirs){
        const nr = r + d.dr, nc = c + d.dc;
        if (nr<0||nr>=N||nc<0||nc>=N) continue;
        const np = idx(nr,nc);
        if (visited.has(np)) continue;
        if (isLockedAdj(p, np, d)){
          visited.add(np);
          q.push(np);
        }
      }
    }
    const aRC = rc(anchorPos);
    return Array.from(visited).map(pos => {
      const prc = rc(pos);
      return { pos, tileId: board[pos], offR: prc.r - aRC.r, offC: prc.c - aRC.c };
    }).sort((m1,m2)=>(m1.offR-m2.offR)||(m1.offC-m2.offC));
  }

  function clusterFitsAt(members, anchorPos){
    const aRC = rc(anchorPos);
    for (const m of members){
      const rr = aRC.r + m.offR;
      const cc = aRC.c + m.offC;
      if (rr<0||rr>=N||cc<0||cc>=N) return false;
    }
    return true;
  }

  // overlap-safe move (복사 버그 방지)
  function applyClusterMoveOverlapSafe(members, toAnchorPos){
    const old = board.slice();
    const srcPositions = members.map(m => m.pos);
    const aRC = rc(toAnchorPos);
    const dstPositions = members.map(m => idx(aRC.r + m.offR, aRC.c + m.offC));

    const srcSet = new Set(srcPositions);
    const dstSet = new Set(dstPositions);

    const next = board.slice();

    for (let i=0;i<members.length;i++){
      next[dstPositions[i]] = old[srcPositions[i]];
    }

    const vacated = [];
    const displaced = [];
    for (let i=0;i<members.length;i++){
      const sp = srcPositions[i];
      const dp = dstPositions[i];
      if (!dstSet.has(sp)) vacated.push(sp);
      if (!srcSet.has(dp)) displaced.push(old[dp]);
    }
    const k = Math.min(vacated.length, displaced.length);
    for (let i=0;i<k;i++){
      next[vacated[i]] = displaced[i];
    }
    board = next;
  }

  // Pop effect
  function popScaleForTile(tileId){
    const t = tilePop.get(tileId);
    if (!t) return 1;
    const a = Math.max(0, Math.min(1, 1 - (t / POP_DUR)));
    return 1 + POP_MAG * Math.sin(a * Math.PI);
  }

  // Fireworks
  function spawnFireworks(){
    const W = canvas.width, H = canvas.height;
    const cx = W/2, cy = H/2;

    const bursts = 8;
    for (let b=0; b<bursts; b++){
      const bx = cx + (Math.random()*160 - 80);
      const by = cy + (Math.random()*120 - 60);
      const count = 22 + Math.floor(Math.random()*18);

      for (let i=0;i<count;i++){
        const ang = Math.random()*Math.PI*2;
        const sp = 120 + Math.random()*180;
        fireworks.push({
          x: bx, y: by,
          vx: Math.cos(ang)*sp,
          vy: Math.sin(ang)*sp,
          life: 0,
          maxLife: 0.75 + Math.random()*0.45,
          size: 1.2 + Math.random()*1.8
        });
      }
    }
  }

  function renderFireworks(dt){
    if (fireworks.length === 0) return;
    const g = 520;
    for (const p of fireworks){
      p.life += dt;
      p.vy += g * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - 1.2*dt);
      p.vy *= (1 - 0.2*dt);
    }
    fireworks = fireworks.filter(p => p.life < p.maxLife);

    ctx.save();
    for (const p of fireworks){
      const t = p.life / p.maxLife;
      const a = Math.max(0, 1 - t);
      const twinkle = 0.6 + 0.4*Math.sin((p.life*18) + (p.x+p.y)*0.01);
      ctx.globalAlpha = a * twinkle;
      ctx.fillStyle = (Math.random() < 0.08) ? "rgba(255,220,140,1)" : "rgba(255,255,255,1)";
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.restore();
  }

  // "착붙" 조건(간단): 이동 후 클러스터 길이가 2 이상이면 팝 + 사운드
  function tryPopAt(pos){
    if (pos == null) return;
    const cl = getCluster(pos);
    if (cl.length >= 2){
      for (const m of cl) tilePop.set(m.tileId, POP_DUR);
      playChime();
    }
  }

  // ----------------------------
  // Rendering
  // ----------------------------
  function render(dt){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#0b0b0c";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    if (!sourceImage){
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "16px system-ui, sans-serif";
      ctx.fillText(isLoading ? "Loading..." : "No image", 18, 26);
      return;
    }

    const br = boardRect();
    ctx.fillStyle = "#121214";
    ctx.fillRect(br.x-2, br.y-2, br.size+4, br.size+4);

    const cell = br.size / N;

    // start hint (원본 힌트)
    if (hintTimer > 0){
      const alpha = Math.min(0.22, (hintTimer / START_HINT_SEC) * 0.22);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.drawImage(sourceImage, br.x, br.y, br.size, br.size);
      ctx.restore();
    }

    const draggingPosSet = new Set(dragging ? dragging.members.map(m => m.pos) : []);

    // draw static tiles
    for (let pos=0; pos<N*N; pos++){
      if (draggingPosSet.has(pos)) continue;

      const tileId = board[pos];
      const { r, c } = rc(pos);
      const x0 = br.x + c*cell + TILE_GAP/2;
      const y0 = br.y + r*cell + TILE_GAP/2;
      const w0 = cell - TILE_GAP;
      const h0 = cell - TILE_GAP;

      const s = popScaleForTile(tileId);
      const cx = x0 + w0/2;
      const cy = y0 + h0/2;
      const w = w0 * s;
      const h = h0 * s;

      ctx.save();
      ctx.translate(cx - w/2, cy - h/2);
      drawTile(tileId, 0, 0, w, h);
      ctx.restore();

      // ✅ 번호 힌트(정답 위치 번호)
      if (numberHintTimer > 0){
        drawHintNumberOnTile(tileId, cx, cy, cell);
      }

      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x0+0.5, y0+0.5, w0-1, h0-1);
    }

    // dragging cluster
    if (dragging){
      const baseX = dragging.mouseX - dragging.grabDX;
      const baseY = dragging.mouseY - dragging.grabDY;

      ctx.save();
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = "#000";
      for (const m of dragging.members){
        const x = baseX + m.offC*cell + 6;
        const y = baseY + m.offR*cell + 8;
        ctx.fillRect(x, y, cell - TILE_GAP, cell - TILE_GAP);
      }
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = DRAG_ALPHA;
      for (const m of dragging.members){
        const x = baseX + m.offC*cell;
        const y = baseY + m.offR*cell;
        drawTile(m.tileId, x, y, cell - TILE_GAP, cell - TILE_GAP);

        // ✅ 드래그 중에도 번호 표시
        if (numberHintTimer > 0){
          const cx = x + (cell - TILE_GAP)/2;
          const cy = y + (cell - TILE_GAP)/2;
          drawHintNumberOnTile(m.tileId, cx, cy, cell);
        }

        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.lineWidth = 2;
        ctx.strokeRect(x+0.5, y+0.5, (cell - TILE_GAP)-1, (cell - TILE_GAP)-1);
      }
      ctx.restore();
    }

    renderFireworks(dt);
  }

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    for (const [id, t] of tilePop.entries()){
      const nt = t - dt;
      if (nt <= 0) tilePop.delete(id);
      else tilePop.set(id, nt);
    }

    if (hintTimer > 0) hintTimer = Math.max(0, hintTimer - dt);
    if (numberHintTimer > 0) numberHintTimer = Math.max(0, numberHintTimer - dt);

    render(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Pointer Events input
  function getCanvasPointFromPointer(evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
    const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  function onPointerDown(evt){
    if (!sourceImage || isLoading) return;
    if (activePointerId != null) return;

    // 오디오 unlock + bgm 시작(모바일 정책)
    startBgmIfNeeded();

    activePointerId = evt.pointerId;
    canvas.setPointerCapture(activePointerId);

    const p = getCanvasPointFromPointer(evt);
    const pos = posFromPoint(p.x, p.y);
    if (pos == null) return;

    const members = getCluster(pos);

    const br = boardRect();
    const cell = br.size / N;
    const { r, c } = rc(pos);
    const gx = br.x + c*cell + TILE_GAP/2;
    const gy = br.y + r*cell + TILE_GAP/2;

    dragging = {
      anchorPos: pos,
      members,
      mouseX: p.x,
      mouseY: p.y,
      grabDX: (p.x - gx),
      grabDY: (p.y - gy),
    };

    evt.preventDefault();
  }

  function onPointerMove(evt){
    if (evt.pointerId !== activePointerId) return;
    if (!dragging) return;

    const p = getCanvasPointFromPointer(evt);
    dragging.mouseX = p.x;
    dragging.mouseY = p.y;

    evt.preventDefault();
  }

  function onPointerUp(evt){
    if (evt.pointerId !== activePointerId) return;
    activePointerId = null;

    if (!dragging) return;

    const p = getCanvasPointFromPointer(evt);
    const dropAnchorPos = posFromPoint(p.x, p.y);

    if (dropAnchorPos != null &&
        dropAnchorPos !== dragging.anchorPos &&
        clusterFitsAt(dragging.members, dropAnchorPos)) {
      applyClusterMoveOverlapSafe(dragging.members, dropAnchorPos);
      tryPopAt(dropAnchorPos);
    } else {
      tryPopAt(dragging.anchorPos);
    }

    dragging = null;

    if (isSolved() && !didClearFx){
      didClearFx = true;
      overlayEl.style.display = "flex";
      spawnFireworks();
      playClear();
    }

    evt.preventDefault();
  }

  canvas.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove, { passive:false });
  window.addEventListener("pointerup", onPointerUp, { passive:false });
  window.addEventListener("pointercancel", onPointerUp, { passive:false });

  // Level + image loading
  function centerCropToSquare(img, size=1024){
    const off = document.createElement("canvas");
    off.width = off.height = size;
    const g = off.getContext("2d");
    const iw = img.naturalWidth, ih = img.naturalHeight;
    const s = Math.min(iw, ih);
    const sx = (iw - s) / 2;
    const sy = (ih - s) / 2;
    g.drawImage(img, sx, sy, s, s, 0, 0, size, size);
    return off;
  }

  async function loadImageToSource(url){
    isLoading = true;
    overlayEl.style.display = "none";

    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        sourceImage = centerCropToSquare(img, 1024);
        isLoading = false;
        resolve(true);
      };
      img.onerror = () => {
        const fallback = document.createElement("canvas");
        fallback.width = fallback.height = 1024;
        const g = fallback.getContext("2d");
        g.fillStyle = "#222";
        g.fillRect(0,0,1024,1024);
        g.fillStyle = "#fff";
        g.font = "bold 44px system-ui, sans-serif";
        g.fillText("Missing image", 60, 120);
        g.font = "20px system-ui, sans-serif";
        g.fillText(url, 60, 160);
        sourceImage = fallback;
        isLoading = false;
        resolve(false);
      };
      img.src = url;
    });
  }

  function updateTopbarLabels(){
    levelLabel.textContent = `Level ${level} / ${TOTAL_LEVELS}`;
    lvText.textContent = `Level ${level} / ${TOTAL_LEVELS}`;
  }

  async function startLevel(lv){
    level = ((lv - 1) % TOTAL_LEVELS) + 1;
    N = getNForLevel(level);

    updateTopbarLabels();

    const pick = IMAGE_POOL[level - 1];
    await loadImageToSource(pick);

    resetBoard();
    shuffleBoard();

    tilePop.clear();
    dragging = null;

    fireworks = [];
    didClearFx = false;

    hintTimer = START_HINT_SEC;
    overlayEl.style.display = "none";
  }

  nextBtn.addEventListener("click", async () => {
    await startLevel(level + 1);
  });

  // boot
  startLevel(level);
})();
</script>
</body>
</html>
